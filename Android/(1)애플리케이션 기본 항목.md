# 애플리케이션 기본 항목

## 공식문서

- Android 앱은 Kotlin, Java, C++ 언어를 사용하여 작성할 수 있다.
- Android SDK 도구는 모든 데이터 및 리소스 파일과 함께 코드를 컴파일하여 하나의 APK를 만든다.
- 한 개의 APK 파일에는 Android 앱의 모든 콘텐츠가 들어 있으며, Android로 구동하는 기기가 앱을 설치할 때 바로 이 파일을 사용한다. → 앱을 설치할 때 사용
- 각 Android 앱은 자체적인 보안 샌드박스에 속하며, 이는 다음과 같은 Android 보안 기능으로 보안된다.
    - 샌드박스 → 외부로부터 들어온 프로그램이 보호된 영역에서 동작해 시스템이 부정하게 조작되는 것을 막는 보안 형태.
    - Android 운영체제는 멀티유저 Linux 시스템으로, 여기서 각 앱은 각기 다른 사용자와 같다.
        - 안드로이드는 리눅스의 일부분을 참고하여 만든 새로운 운영체제(리눅스 커널을 사용)
    - 기본적으로 시스템이 각 앱에 고유한 Linux ID를 할당한다.(이 ID는 시스템만 사용할 수 있으며 앱에서는 인식하지 못함).
    - 시스템은 앱 안의 모든 파일에 대해 권한을 설정하여 해당 앱에 할당된 사용자 ID만 이에 액세스할 수 있도록 한다.
    - 각 프로세스에는 자체적인 가상 머신(VM)이 있고, 그렇기 떄문에 한 앱의 코드가 다른 앱과는 격리된 상태로 실행된다. → Dalvik VM. ART VM
    - 기본적으로 모든 앱이 앱 자체의 Linux 프로세스에서 실행된다. Android 시스템은 앱의 구성 요소 중 어느 하나라도 실행해야 하는 경우 프로세스를 시작하고, 더 이상 필요 없거나 시스템이 다른 앱을 위해 메모리를 복구해야 하는 경우 해당 프로세스를 종료한다.

### 앱 구성 요소

- 각 구성 요소는 시스템이나 사용자가 앱에 들어올 수 있는 진입점이다.
- 각 요소는 뚜렷한 목적을 수행하고 각자 나름의 수명 주기가 있어 구성 요소의 생성 및 소멸 방식을 정의한다.

### 액티비티

- 사용자와 상호작용하기 위한 진입점 → 사용자 인터페이스(UI)를 포함한 화면 하나를 나타낸다.
- 액티비티는 다음과 같이 시스템과 앱의 주요 상호작용을 돕는다.
    - 사용자가 현재 관심을 가지고 있는 상황(화면에 표시된 것)을 추적하여 액티비티를 호스팅하는 프로세스를 시스템에서 계속 실행 하게 한다.
    - 이전에 사용한 프로세스에 사용자가 다시 찾을 만한 액티비티(중단되 액티비티)가 있다는 것을 알고, 해당 프로세스를 유지하는 데 더 높은 우선순위를 부여한다.
    - 앱이 프로세스를 종료하도록 도와서 이전 상태가 복원되는 동시에 사용자가 액티비티로 돌아갈 수 있게 한다.
    - 앱이 서로 사용자 플로우를 구현하고 시스템이 이러한 플로우를 조정하기 위한 수단을 제공한다. → 액티비티는 서로 독립적이기 때문에 다른 앱에서 특정 액티비티를 시작하는 것이 가능!

### 서비스

- 백그라운드에서 앱을 계속 실행하기 위한 다목적 진입점이다.
- 백그라운드에서 실행되는 구성 요소로, 오랫동안 실행되는 작업을 수행하거나 원격 프로세스를 위한 작업을 수행한다.
- 사용자 인터페이스를 제공하지 않는다.
- 예를 들면, 백그라운드에서 음악을 재생하거나, 사용자와 액티비티 간의 상호작용을 차단하지 않고 네트워크를 통해 데이터를 가져올 수도 있다.
- 다른 구성 요소가 서비스를 시작한 다음 실행되도록 두거나 자신에게 바인딩하여 상호작용하게 할 수도 있다.
- 백그라운드에서 데이터를 동기화하거나 음악을 재생하는 것은 두 가지 유형의 시작된 서비스를 나타내는데, 이는 시스템이 서비스를 처리하는 방식을 변경한다.
    - 음악 재생은 사용자가 바로 인식할 수 있는 작업이다. 따라서 앱은 사용자에게 이와 관련하여 알림을 보내고 음악 재생을 포그라운드로 옮기라고 시스템에 지시한다. → 이 경우, 시스템은 이 서비스의 프로세스가 계속 실행되도록 많은 노력을 기울여야 한다.
    - 정기적인 백그라운드 서비스는 사용자가 실행되고 있다고 직접 인식할 수 없는 작업이므로 시스템은 좀 더 자유롭게 프로세스를 관리할 수 있다. → 사용자와 좀 더 직접적인 관련이 있는 작업에 RAM이 필요할 경우 이서비스를 종료할 수 있다.(다른 프로세스 실행으로 메모리가 부족할때)

### Broadcast Receiver

- 시스템이  사용자 플로우 밖에서 이벤트를 앱에 전달하도록 지원하는 구성 요소, 앱이 시스템 전체의 브로드캐스트 알림에 응답할 수 있게 한다.
- Broadcast Receiver도 앱으로 들어갈 수 있는 또 다른 명확한 진입점이기 때문에 현재 실행되지 않은 앱에도 시스템이 브로드캐스트를 전달할 수 있다.
- 대다수의 브로드캐스트는 시스템에서 발생한다. 화면이 꺼졌거나 배터리가 부족하거나 사진을 캡처했다고 알리는 브로드캐스트가 대표적이다.
- 앱도 브로드캐스트를 시작할 수 있다.(허슬 풋볼에서의 입단과 같이 실시간으로 전달할때)
    - 다른 앱에 일부 데이터가 기기에 다운로드 되었고 이를 사용할 수 있다는 것을 알리는데 사용한다.
- Broadcast Receiver는 사용자 인터페이스를 표시하지 않지만, 상태 표시줄 알림을 생성하여 사용자에게 브로드캐스트 이벤트가 발생했다고 알릴 수 있다.
- 다만 Broadcast Receiver는 그저 다른 구성 요소로의 게이트웨이인 경우가 더 보편적이고, 극소량의 작업만 수행하고 만들어진 경우가 많다.
    - JobService를 예약 및 시작하여 JobScheduler가 포함된 이벤트를 기초로 어떤 작업을 수행하게 할 수 있다.

### 콘텐츠 제공자

- 파일 시스템, SQLite 데이터베이스, 웹상이나 앱이 액세스할 수 있는 다른 모든 영구 저장 위치에 저장 가능한 앱 데이터의 공유형 집합을 관리한다.
- 다른 앱은 콘텐츠 제공자를 통해 해당 데이터를 쿼리하거나, 콘텐츠 제공자가 허용할 경우에는 수정도 가능하다.
    - Android 시스템은 사용자의 연락처 정보를 관리하는 콘텐츠 제공자를 제공한다.
- 적절한 권한을 가진 앱이라면 콘텐츠 제공자를 쿼리하여 특정한 인물에 대한 정보를 읽고 쓸 수 있다.
- 시스템의 경우 콘텐츠 제공자는 URI 구성표로 식별되고 이름이 지정된 데이터 항목을 게시할 목적으로 앱에 진입하기 위한 입구이다.
- 따라서 앱에서 URI 네임스페이스에 넣을 데이터를 매핑할 방식을 결정하고, 해당 URI를 다른 엔터티에 전달할 수 있다. 이를 전달받은 엔터티는 URI를 사용하여 데이터에 액세스한다.
- URI를 할당하더라도 앱을 계속 실행할 필요가 없으므로 URI를 소유한 앱이 종료된 후에도 URI를 유지할 수 있다. 시스템은 URI를 소유한 앱이 해당 URI에서 앱의 데이터를 검색할 때만 실행되도록 하면 된다.
- 이 URI는 중요하고 조밀한 보안 모델을 제공한다.
    - 앱은 클립보드에 있는 이미지에 URI를 할당하고 콘텐츠 제공자가 검색하도록 하여, 다른 앱이 자유롭게 이미지에 액세스하지 못하게 막을 수 있다.
    - 두 번째 앱이 클립보드에서 해당 URI에 액세스하려고 시도하면 시스템에서는 임시 URI 권한을 부여하여 그 앱이 데이터에 액세스하도록 허용할 수 있다. → 두 번째 앱에서는 URI 뒤에 있는 데이터 외에 다른 것에는 액세스할 수 없다.

- Android 시스템 디자인은 어떤 앱이든 다른 앱의 구성 요소를 시작할 수 있다.
    - 사용자가 기기 카메라로 사진을 캡처하기를 바라는 경우, 그런 작업을 수행하는 다른 앱이 있을 가능성이 높다.
    - 사진을 캡처하는 액티비티를 직접 개발하는 대신 우리의 앱에서 그 앱을 사용하면 된다.
    - 카메라 앱의 코드를 포함하거나 링크할 필요도 없다. 대신 사진을 캡처하는 카메라 앱에서 액티비티를 시작하기만 하면된다.
    - 작업이 완료되면 사진이 앱으로 반환되기까지 하여 바로 사용할 수 있다.
- 시스템이 구성 요소를 시작할 때 그 앱에 대한 프로세스를 시작하고, 해당 구성요소에 필요한 클래스를 인스턴스화한다.
    - 카메라 앱 내에서 사진을 캡쳐하는 액티비티를 시작하면, 해당 액티비티는 여러분 앱의 프로세스가 아니라 카메라 앱에 속한 프로세스에서 실행된다. → 대부분의 다른 시스템에서 실행되는 앱과 달리 Android 앱은 단일한 진입 지점이 없다.
- 시스템이 다른 앱에 대한 액세스를 제한하는 파일 권한을 가지고 각 앱을 별도의 프로세스에서 실행하기 때문에, 우리의 앱은 다른 앱에서 직접 구성요소를 활성화할 수 없다.
- 다만 Android 시스템으로는 이것이 가능하다. 다른 앱에 있는 구성 요소를 활성화하려면 시스템에 메세지를 전달하여 특정 구성 요소를 시작하고자 하는 인텐트를 밝혀야 한다. → 시스템이 대신 해당 구성 요소를 활성화해준다.

### 구성 요소 활성화

- 액티비티, 서비스, Broadcast Receiver는 인텐트라는 비동기식 메세지로 활성화된다.
- 인텐트는 런타임에서 각 구성 요소를 서로 바인딩한다. → 메신저
- 구성 요소가 어느 앱에 속하든 관계없이 다른 구성 요소로부터 작업을 요청하는 역할을 한다.
- 인텐트는 Intent 객체로 생성되며, 특정 구성 요소(명시적 인텐트)를 활성화할지 아니면 구성 요소의 특정 유형(암시적 인텐트)를 활성화할지 나타내는 메세지를 전달한다.
- 액티비티와 서비스의 경우, 인텐트는 수행할 작업을 정의하며(무언가를 보거나 보내는 작업), 시작되는 구성 요소가 알아야 할 것이 많이 있기는 하지만 그 중에서도 작업을 수행할 데이터의 URI를 지정할 수 있다.
    - 인텐트는 액티비티에 이미지를 표시하거나 웹 페이지를 열라는 요청을 전달할 수 있다.
    - 경우에 따라 결과를 수신하기 위해 액티비티를 시작할 수 있다.
    - 이 경우, 액티비티도 Intent에서 결과를 반환한다.
- Broadcast Receiver의 경우, 인텐트는 단순히 브로드캐스트될 알림을 정의한다.
    - 예를 들어 기기 배터리 잔량이 낮다는 것을 나타내는 브로드캐스트에는 배터리 부족을 나타내는 알려진 작업 문자열만 포함된다.
- Content Provider는 인텐트로 활성화되지 않는다.